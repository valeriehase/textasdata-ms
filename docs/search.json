[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Automatisierte Inhaltsanalyse",
    "section": "",
    "text": "Quelle: Foto von AltumCode auf Unsplash"
  },
  {
    "objectID": "index.html#infos-zum-workshop",
    "href": "index.html#infos-zum-workshop",
    "title": "Automatisierte Inhaltsanalyse",
    "section": "Infos zum Workshop",
    "text": "Infos zum Workshop\n\nMethodenworkshop am Institut f√ºr Kommunikationswissenschaft, Universit√§t M√ºnster\nüìÖ 24-25. Juli 2024\nWorkshop-Leitung:\n\nValerie Hase (Ludwig-Maximilians-Universit√§t M√ºnchen). Mehr Infos: github.com/valeriehase & valerie-hase.com\nUnterst√ºtzung durch Teaching Assistant Luisa Kutlar (Ludwig-Maximilians-Universit√§t M√ºnchen). Mehr Infos: github.com/luisakutlar"
  },
  {
    "objectID": "index.html#materialien",
    "href": "index.html#materialien",
    "title": "Automatisierte Inhaltsanalyse",
    "section": "Materialien",
    "text": "Materialien\n\nDaten\nDatensatz 1: IMDb Top-Rated TV Series Dataset(Download-Link). Verf√ºgbar unter MIT Lizenz via Kaggle.\n\n\n Download TV Dataset\n\n\n\n\nFolien & R-Code\nSitzung 1Ô∏è‚É£: Einf√ºhrung in die automatisierte Inhaltsanalyse & Preprocessing\n\nFolien\nTutorial\n\nSitzung 2Ô∏è‚É£: Co-Occurence-Analysen\n\nFolien\nTutorial\n\nSitzung 3Ô∏è‚É£: Diktion√§re\n\nFolien\nTutorial\n\nSitzung 4Ô∏è‚É£: Topic Modeling\n\nFolien\nTutorial\n\nSitzung 5Ô∏è‚É£: Qualit√§tskriterien\n\nFolien\nTutorial\n\nSitzung 6Ô∏è‚É£: Ausblick\n\nFolien\nTutorial"
  },
  {
    "objectID": "index.html#weiterf√ºhrende-tutorials",
    "href": "index.html#weiterf√ºhrende-tutorials",
    "title": "Automatisierte Inhaltsanalyse",
    "section": "Weiterf√ºhrende Tutorials",
    "text": "Weiterf√ºhrende Tutorials\n\nBail, C. Day 3: Automated Text Analysis. Link\nBernauer J, & Traber D. Quantitative Analysis of Political Text. Link\nHase, V. (2022). Text as Data Methods in R. Link\nHase, V. (2023). Advanced Text Analysis. Link\nSanchez, G. (2014). Handling Strings with R. Link\nSilge, J., & Robinson, D. Text mining with R: A tidy approach. Link\nPuschmann, C., & Haim, R. Automated Content Analysis with R. Link\nUnkel, J. (2020). Methodische Vertiefung: Computational Methods mit R und R Studio. Link\nWatanabe, K., & M√ºller, S (2023). Quanteda Tutorials. Link"
  },
  {
    "objectID": "index.html#weiterf√ºhrende-literatur",
    "href": "index.html#weiterf√ºhrende-literatur",
    "title": "Automatisierte Inhaltsanalyse",
    "section": "Weiterf√ºhrende Literatur",
    "text": "Weiterf√ºhrende Literatur\n\nBaden, C., Pipal, C., Schoonvelde, M., & Van Der Velden, M. A. C. G. (2022). Three Gaps in Computational Text Analysis Methods for Social Sciences: A Research Agenda. Communication Methods and Measures, 16(1), 1‚Äì18. https://doi.org/10.1080/19312458.2021.2015574\nBenoit, K. (2019). Text as data: An overview. In Cuirini, L., & Franzese, R. (Eds.), Handbook of Research Methods in Political Science and International Relations. Preprint\nBoumans, J. W., & Trilling, D. (2016). Taking Stock of the Toolkit: An overview of relevant automated content analysis approaches and techniques for digital journalism scholars. Digital Journalism, 4(1), 8‚Äì23. https://doi.org/10.1080/21670811.2015.1096598\nGrimmer, J., Roberts, M. E., & Stewart, B. M. (2022). Text as data: A new framework for machine learning and the social sciences. Princeton University Press.\nG√ºnther, E., & Quandt, T. (2016). Word Counts and Topic Models: Automated text analysis methods for digital journalism research. Digital Journalism, 4(1), 75‚Äì88. https://doi.org/10.1080/21670811.2015.1093270\nHaim, M. (2023). Computational Communication Science: Eine Einf√ºhrung. Springer Fachmedien Wiesbaden. https://doi.org/10.1007/978-3-658-40171-9\nHase, V. (2023). Automated Content Analysis. In F. Oehmer, S. H. Kessler, E. Humprecht, K. Sommer, & L. Castro Herrero (eds.),¬†Handbook of Standardized Content Analysis: Applied Designs to Research Fields of Communication Science. VS Springer (pp.¬†23‚Äì36).¬†https://doi.org/10.1007/978-3-658-36179-2_3\nJ√ºnger, J., & G√§rtner, C. (2023). Computational Methods f√ºr die Sozial- und Geisteswissenschaften. Springer Fachmedien Wiesbaden. https://doi.org/10.1007/978-3-658-37747-2\nQuinn, K. M., Monroe, B. L., Colaresi, M., Crespin, M. H., & Radev, D. R. (2010). How to Analyze Political Attention with Minimal Assumptions and Costs. American Journal of Political Science, 54(1), 209‚Äì228. https://doi.org/10.1111/j.1540-5907.2009.00427.x\nAtteveldt, W. van, Trilling, D., & Arc√≠la Calder√≥n, C. (2022). Computational analysis of communication: A practical introduction to the analysis of texts, networks, and images with code examples in Python and R. Wiley Blackwell.\nWilkerson, J., & Casas, A. (2017). Large-Scale Computerized Text Analysis in Political Science: Opportunities and Challenges. Annual Review of Political Science, 20(1), 529‚Äì544. https://www.annualreviews.org/doi/10.1146/annurev-polisci-052615-025542"
  },
  {
    "objectID": "01-begr√ºssung.html",
    "href": "01-begr√ºssung.html",
    "title": "\nAutomatisierte Inhaltsanalyse\n",
    "section": "",
    "text": "Automatisierte Inhaltsanalyse\nSitzung 1Ô∏è‚É£: Begr√º√üung\nLeitung: Valerie Hase (Ludwig-Maximilians-Universit√§t M√ºnchen)\nüëâ github.com/valeriehase & valerie-hase.com\nTeaching Assistant: Luisa Kutlar (Ludwig-Maximilians-Universit√§t M√ºnchen)\nüëâ github.com/luisakutlar"
  },
  {
    "objectID": "01-begr√ºssung.html#wer-seid-ihr",
    "href": "01-begr√ºssung.html#wer-seid-ihr",
    "title": "Automatisierte Inhaltsanalyse_ Workshop",
    "section": "Wer seid ihr?",
    "text": "Wer seid ihr?\nBitte die Hand heben ü§ö, wenn ihr ‚Ä¶.\n\n\nmit automatisierter Inhaltsanalyse gearbeitet habt\nR regelm√§√üig nutzt\nandere Programmiersprachen (z. B. Python) regelm√§√üig nutzt"
  },
  {
    "objectID": "01-begr√ºssung.html#wer-sind-wir",
    "href": "01-begr√ºssung.html#wer-sind-wir",
    "title": "Automatisierte Inhaltsanalyse_ Workshop",
    "section": "Wer sind wir?",
    "text": "Wer sind wir?"
  },
  {
    "objectID": "01-begr√ºssung.html#vielen-dank-f√ºr-die-organisation",
    "href": "01-begr√ºssung.html#vielen-dank-f√ºr-die-organisation",
    "title": "Automatisierte Inhaltsanalyse_ Workshop",
    "section": "Vielen Dank f√ºr die Organisation üôå",
    "text": "Vielen Dank f√ºr die Organisation üôå\nShoutout an: Mittelbaunetzwerk Journalismusforschung & Mittelbaunetzwerk Wissenschaftskommunikation\n\nJulia Metag\nFranca Singh\nJakon J√ºnger"
  },
  {
    "objectID": "01-begr√ºssung.html#worum-geht-es-heute",
    "href": "01-begr√ºssung.html#worum-geht-es-heute",
    "title": "Automatisierte Inhaltsanalyse_ Workshop",
    "section": "Worum geht es heute?",
    "text": "Worum geht es heute?\n\n\n‚úÖ A\n‚ùå D"
  },
  {
    "objectID": "01-begr√ºssung.html#ablauf",
    "href": "01-begr√ºssung.html#ablauf",
    "title": "Automatisierte Inhaltsanalyse_ Workshop",
    "section": "Ablauf",
    "text": "Ablauf\n\nFragen? ü§î\n\n\n\n\nAutomatisierte Inhaltsanalyse - Workshop Universit√§t M√ºnster, Juli 2024"
  },
  {
    "objectID": "01-begr√ºssung.html#section",
    "href": "01-begr√ºssung.html#section",
    "title": "Automatisierte Inhaltsanalyse_ Workshop",
    "section": "",
    "text": "Fragen? ü§î\n\n\n\n\nAutomatisierte Inhaltsanalyse - Workshop Universit√§t M√ºnster, Juli 2024"
  },
  {
    "objectID": "tutorial/sitzung2.html",
    "href": "tutorial/sitzung2.html",
    "title": "Sitzung 2",
    "section": "",
    "text": "Paket ‚Äúreadtext‚Äù installieren\nWenn ihr beim Workshop kein Internet habt, k√∂nnt ihr das Paket auch weglassen.\n\ninstall.packages(\"readtext\")\n\n\n\nPakete ‚Äúaktivieren‚Äù\nAls n√§chstes laden wir √ºber die folgenden Befehle die Pakete, mit denen wir Daten einlesen und bereinigen werden.\n\nlibrary(\"readtext\")"
  },
  {
    "objectID": "tutorial/Sitzung2_EinlesenBereinigung.html",
    "href": "tutorial/Sitzung2_EinlesenBereinigung.html",
    "title": "Session 2: Einlesen & Bereinigen von Text",
    "section": "",
    "text": "Paket ‚Äúreadtext‚Äù installieren\nWenn ihr beim Workshop kein Internet habt, k√∂nnt ihr das Paket auch weglassen.\n\ninstall.packages(\"readtext\")\n\n\n\nPakete ‚Äúaktivieren‚Äù\nAls n√§chstes laden wir √ºber die folgenden Befehle die Pakete, mit denen wir Daten einlesen und bereinigen werden.\n\nlibrary(\"readtext\")"
  },
  {
    "objectID": "tutorial/02-einlesen-bereinigen.html",
    "href": "tutorial/02-einlesen-bereinigen.html",
    "title": "Sitzung 2 - Einlesen & Bereinigen von Text",
    "section": "",
    "text": "Zun√§chst installieren und laden wir alle Packete, die wir heute und morgen brauchen.\n\n#install.packages(\"RCurl\")\n#install.packages(\"quanteda\")\n#install.packages(\"tidyverse)\n#install.packages(\"dplyr\")\n#install.packages(\"quanteda.textplots\")\n#install.packages(\"quanteda.textstats\")\n#install.packages(\"udpipe\")\n\nlibrary(\"RCurl\")\nlibrary(\"quanteda\")\nlibrary(\"tidyverse\")\nlibrary(\"dplyr\")\nlibrary(\"quanteda.textplots\")\nlibrary(\"quanteda.textstats\")\nlibrary(\"udpipe\")\n\nDann laden wir die Datei die hinter dem Link liegt mit der Funktion getURL() aus dem package Rcurl herunter. Mit einem Blick in das Environment sehen wir, dass die einzelnen W√∂rter mit einem ; getrennt werden . Daher brauchen wir die Funktion read.csv2() aus dem utils Packet - das Packet ist vorinstalliert und immer geladen - um die Daten in R einzulesen. Der Datensatz wird im Objekt daten_df gespeichert.\n\nurl &lt;-  getURL(\"https://raw.githubusercontent.com/valeriehase/Salamanca-CSS-SummerSchool/main/Processing%20text%20and%20text%20as%20data/data_tvseries.csv\")\ndaten_df &lt;-  read.csv2(text = url)\n\nAlternativ k√∂nnen Daten in einer .csv Datei auch mit einem , voneinander abgetrennt sein. Hier br√§uchte es dann die Funktion read.csv() zum Einlesen.\nNach dem Einlesen der Daten ist es √ºblich sich zun√§chst einen √úberblick √ºber die Daten zu verschaffen und zu kontrollieren, ob alles korrekt eingelesen wurde.\n\nhead(daten_df)\n\n                Title      Year Parental.Rating Rating Number.of.Votes\n1  1. Game of Thrones 2011‚Äì2019           TV-MA    9.2            2.3M\n2     2. Breaking Bad 2008‚Äì2013           TV-MA    9.5            2.1M\n3  3. Stranger Things 2016‚Äì2025           TV-14    8.7            1.3M\n4          4. Friends 1994‚Äì2004           TV-14    8.9            1.1M\n5 5. The Walking Dead 2010‚Äì2022           TV-MA    8.1            1.1M\n6         6. Sherlock 2010‚Äì2017           TV-14    9.1              1M\n                                                                                                                                                                                                                                    Description\n1                                                                                                           Nine noble families fight for control over the lands of Westeros, while an ancient enemy returns after being dormant for millennia.\n2                                                                    A chemistry teacher diagnosed with inoperable lung cancer turns to manufacturing and selling methamphetamine with a former student in order to secure his family's future.\n3                                                                                          When a young boy vanishes, a small town uncovers a mystery involving secret experiments, terrifying supernatural forces and one strange little girl.\n4                                                                                                        Follows the personal and professional lives of six twenty to thirty year-old friends living in the Manhattan borough of New York City.\n5                                                                                                              Sheriff Deputy Rick Grimes wakes up from a coma to learn the world is in ruins and must lead a group of survivors to stay alive.\n6 The quirky spin on Conan Doyle's iconic sleuth pitches him as a \"high-functioning sociopath\" in modern-day London. Assisting him in his investigations: Afghanistan War vet John Watson, who's introduced to Holmes by a mutual acquaintance.\n\nstr(daten_df)\n\n'data.frame':   900 obs. of  6 variables:\n $ Title          : chr  \"1. Game of Thrones\" \"2. Breaking Bad\" \"3. Stranger Things\" \"4. Friends\" ...\n $ Year           : chr  \"2011‚Äì2019\" \"2008‚Äì2013\" \"2016‚Äì2025\" \"1994‚Äì2004\" ...\n $ Parental.Rating: chr  \"TV-MA\" \"TV-MA\" \"TV-14\" \"TV-14\" ...\n $ Rating         : num  9.2 9.5 8.7 8.9 8.1 9.1 8.1 8.6 8.3 9 ...\n $ Number.of.Votes: chr  \"2.3M\" \"2.1M\" \"1.3M\" \"1.1M\" ...\n $ Description    : chr  \"Nine noble families fight for control over the lands of Westeros, while an ancient enemy returns after being do\"| __truncated__ \"A chemistry teacher diagnosed with inoperable lung cancer turns to manufacturing and selling methamphetamine wi\"| __truncated__ \"When a young boy vanishes, a small town uncovers a mystery involving secret experiments, terrifying supernatura\"| __truncated__ \"Follows the personal and professional lives of six twenty to thirty year-old friends living in the Manhattan bo\"| __truncated__ ...\n\nView(daten_df)"
  },
  {
    "objectID": "tutorial/02-einlesen-bereinigen.html#preprocessing-1",
    "href": "tutorial/02-einlesen-bereinigen.html#preprocessing-1",
    "title": "Sitzung 2 - Einlesen & Bereinigen von Text",
    "section": "Preprocessing",
    "text": "Preprocessing"
  },
  {
    "objectID": "tutorial/02-einlesen-bereinigen.html#encoding-issues-checken",
    "href": "tutorial/02-einlesen-bereinigen.html#encoding-issues-checken",
    "title": "Sitzung 2 - Einlesen & Bereinigen von Text",
    "section": "2.1 Encoding issues checken",
    "text": "2.1 Encoding issues checken\nNach dem Einlesen haben wir bereits einen Blick in den Datensatz geworfen. Nun schauen wir uns gezielt die Textvariable description an, um zu √ºberpr√ºfen, ob alle Zeichen richtig dargestellt werden.\n\ndaten_df %&gt;% \n   select(Description) %&gt;% \n  head()\n\n                                                                                                                                                                                                                                    Description\n1                                                                                                           Nine noble families fight for control over the lands of Westeros, while an ancient enemy returns after being dormant for millennia.\n2                                                                    A chemistry teacher diagnosed with inoperable lung cancer turns to manufacturing and selling methamphetamine with a former student in order to secure his family's future.\n3                                                                                          When a young boy vanishes, a small town uncovers a mystery involving secret experiments, terrifying supernatural forces and one strange little girl.\n4                                                                                                        Follows the personal and professional lives of six twenty to thirty year-old friends living in the Manhattan borough of New York City.\n5                                                                                                              Sheriff Deputy Rick Grimes wakes up from a coma to learn the world is in ruins and must lead a group of survivors to stay alive.\n6 The quirky spin on Conan Doyle's iconic sleuth pitches him as a \"high-functioning sociopath\" in modern-day London. Assisting him in his investigations: Afghanistan War vet John Watson, who's introduced to Holmes by a mutual acquaintance.\n\n\nIn diesem Fall gibt es keine Encoding issues.\nWas tun falls doch?\n\n\nBeim Einlesen das richtige Encoding mitgeben\nManuell bereinigen\n\n\nBeim manuellen Bereinigen kann die Funktion gsub() helfen, die Zeichenketten ersetzen kann. Zum Beispiel so:\n\n#string mit encoding issues\nstring &lt;- \"Sch√É¬∂ne Gr√É¬º√É¬üe aus M√É¬ºnchen!\"\nprint(string)\n\n[1] \"Sch√É¬∂ne Gr√É¬º√É\\u009fe aus M√É¬ºnchen!\"\n\n#√úberpr√ºfen, ob \"M√ºnchen\" in string vorhanden ist\ncontains_m√ºnchen &lt;- grepl(\"M√ºnchen\", string)\nprint(contains_m√ºnchen)\n\n[1] FALSE\n\n#Zeichen manuell ersetzen\nstring_bereinigt &lt;- string %&gt;% \n  gsub(pattern = \"√É¬∂\", replacement =\"√∂\") %&gt;% \n  gsub(pattern = \"√É¬º\", replacement = \"√º\") %&gt;% \n  gsub(pattern = \"√É\\u009f\", replacement = \"√ü\") \nprint(string_bereinigt)\n\n[1] \"Sch√∂ne Gr√º√üe aus M√ºnchen!\"\n\n#√úberpr√ºfen, ob \"M√ºnchen\" in string_bereinigt vorhanden ist\ncontains_m√ºnchen &lt;- grepl(\"aus\", string_bereinigt)\nprint(contains_m√ºnchen)\n\n[1] TRUE"
  },
  {
    "objectID": "tutorial/02-einlesen-bereinigen.html#datenbereinigung",
    "href": "tutorial/02-einlesen-bereinigen.html#datenbereinigung",
    "title": "Sitzung 2 - Einlesen & Bereinigen von Text",
    "section": "Datenbereinigung",
    "text": "Datenbereinigung"
  },
  {
    "objectID": "tutorial/02-einlesen-bereinigen.html#normalisierung",
    "href": "tutorial/02-einlesen-bereinigen.html#normalisierung",
    "title": "Sitzung 2 - Einlesen & Bereinigen von Text",
    "section": "2.3 Normalisierung",
    "text": "2.3 Normalisierung\nMit der Funktion tokens_tolower()aus dem quanteda Packet k√∂nnen alle Buchstaben in Kleinbuchstaben umgeformt werden.\n\ndaten_tokens &lt;- tokens_tolower(daten_tokens)\n\ndaten_tokens %&gt;% \n  head(n=3)\n\nTokens consisting of 3 documents.\ntext1 :\n [1] \"nine\"     \"noble\"    \"families\" \"fight\"    \"for\"      \"control\" \n [7] \"over\"     \"the\"      \"lands\"    \"of\"       \"westeros\" \"while\"   \n[ ... and 9 more ]\n\ntext2 :\n [1] \"a\"             \"chemistry\"     \"teacher\"       \"diagnosed\"    \n [5] \"with\"          \"inoperable\"    \"lung\"          \"cancer\"       \n [9] \"turns\"         \"to\"            \"manufacturing\" \"and\"          \n[ ... and 13 more ]\n\ntext3 :\n [1] \"when\"      \"a\"         \"young\"     \"boy\"       \"vanishes\"  \"a\"        \n [7] \"small\"     \"town\"      \"uncovers\"  \"a\"         \"mystery\"   \"involving\"\n[ ... and 10 more ]"
  },
  {
    "objectID": "tutorial/02-einlesen-bereinigen.html#tokenisierung-zahlen-urls-etc.-entfernen",
    "href": "tutorial/02-einlesen-bereinigen.html#tokenisierung-zahlen-urls-etc.-entfernen",
    "title": "Sitzung 2 - Einlesen & Bereinigen von Text",
    "section": "2.2 Tokenisierung & Zahlen, URLs, etc. entfernen",
    "text": "2.2 Tokenisierung & Zahlen, URLs, etc. entfernen\nDie Funktion tokens()von quanteda erm√∂glicht es uns bei der Aufteilung von Text in tokens direkt bestimmte Zeichen zu entfernen. Hier entfernen wir Punkte, Zahlen, URLs und Symbole.\n\ndaten_tokens &lt;- tokens(daten_df$Description, what = \"word\", remove_punct = TRUE, remove_numbers = TRUE, remove_url = TRUE, remove_symbols = TRUE) #wollen wir das alles entfernen?\n\ndaten_tokens %&gt;% \n  head(n=3)\n\nTokens consisting of 3 documents.\ntext1 :\n [1] \"Nine\"     \"noble\"    \"families\" \"fight\"    \"for\"      \"control\" \n [7] \"over\"     \"the\"      \"lands\"    \"of\"       \"Westeros\" \"while\"   \n[ ... and 9 more ]\n\ntext2 :\n [1] \"A\"             \"chemistry\"     \"teacher\"       \"diagnosed\"    \n [5] \"with\"          \"inoperable\"    \"lung\"          \"cancer\"       \n [9] \"turns\"         \"to\"            \"manufacturing\" \"and\"          \n[ ... and 13 more ]\n\ntext3 :\n [1] \"When\"      \"a\"         \"young\"     \"boy\"       \"vanishes\"  \"a\"        \n [7] \"small\"     \"town\"      \"uncovers\"  \"a\"         \"mystery\"   \"involving\"\n[ ... and 10 more ]"
  },
  {
    "objectID": "tutorial/02-einlesen-bereinigen.html#stopw√∂rter-entfernen",
    "href": "tutorial/02-einlesen-bereinigen.html#stopw√∂rter-entfernen",
    "title": "Sitzung 2 - Einlesen & Bereinigen von Text",
    "section": "2.4 Stopw√∂rter entfernen",
    "text": "2.4 Stopw√∂rter entfernen"
  },
  {
    "objectID": "tutorial/02-einlesen-bereinigen.html#vereinheitlichung",
    "href": "tutorial/02-einlesen-bereinigen.html#vereinheitlichung",
    "title": "Sitzung 2 - Einlesen & Bereinigen von Text",
    "section": "2.5 Vereinheitlichung",
    "text": "2.5 Vereinheitlichung\nOft gibt es W√∂rter, die unterschiedliche Abk√ºrzungen oder Schreibweisen haben. Nehmen wir das Beispiel der Europ√§ischen Union, die auch mit EU oder E.U. abgek√ºrzt wird. Mit Hilfe der Funktion gsub() k√∂nnen wir strings mit anderen strings ersetzen.\n\nstring &lt;- \"Bei den EU Wahlen k√∂nnen alle B√ºrger*innen der Europ√§ischen Union w√§hlen gehen.\"\nstring &lt;- gsub(\"Europ√§ischen Union\", \"EU\", string)\nprint(string)\n\n[1] \"Bei den EU Wahlen k√∂nnen alle B√ºrger*innen der EU w√§hlen gehen.\""
  },
  {
    "objectID": "tutorial/02-einlesen-bereinigen.html#lemmatizingstemming",
    "href": "tutorial/02-einlesen-bereinigen.html#lemmatizingstemming",
    "title": "Sitzung 2 - Einlesen & Bereinigen von Text",
    "section": "2.6 Lemmatizing/Stemming",
    "text": "2.6 Lemmatizing/Stemming"
  },
  {
    "objectID": "tutorial/02-einlesen-bereinigen.html#selteneh√§ufige-features-entfernen",
    "href": "tutorial/02-einlesen-bereinigen.html#selteneh√§ufige-features-entfernen",
    "title": "Sitzung 2 - Einlesen & Bereinigen von Text",
    "section": "2.8 Seltene/h√§ufige features entfernen",
    "text": "2.8 Seltene/h√§ufige features entfernen\nIm letzten Schritt des Preprocessings entfernen wir h√§ufig und selten vorkommende features aus der dfm. Das geht mit der Funktion dfm_trim()aus dem quanteda Packet.\nEs k√∂nnen unterschiedliche thresholds gesetzt werden - hier lassen wir nur features in der dfm die mindestens in 0.5% und h√∂chstens in 99% der Dokumente vorkommen. Das Argument docfreq_type = \"prop\"berechnet den Anteil der Dokumente, die ein bestimmtes feature beinhalten relativ zur Gesamtzahl der Dokumente. verbose = TRUEprinted w√§hrend der Ausf√ºhrung der Funktion Informationen √ºber den Rechenvorgang in die Konsole.\n\ndaten_dfm &lt;- daten_dfm %&gt;% \n  dfm_trim( min_docfreq = 0.005, \n            max_docfreq = 0.99, \n            docfreq_type = \"prop\", \n            verbose = TRUE)"
  },
  {
    "objectID": "tutorial/02-einlesen-bereinigen.html#stoppw√∂rter-entfernen",
    "href": "tutorial/02-einlesen-bereinigen.html#stoppw√∂rter-entfernen",
    "title": "Sitzung 2 - Einlesen & Bereinigen von Text",
    "section": "2.4 Stoppw√∂rter entfernen",
    "text": "2.4 Stoppw√∂rter entfernen\nEs gibt verschiedene M√∂glichkeiten, Stoppw√∂rter zu entfernen. Am einfachsten ist dies mithilfe der in quanteda integrierten Stoppwortlisten m√∂glich. Diese sind in mehreren Sprachen verf√ºgbar, darunter auch Deutsch.\n\nstopwords(\"english\")\n\n  [1] \"i\"          \"me\"         \"my\"         \"myself\"     \"we\"        \n  [6] \"our\"        \"ours\"       \"ourselves\"  \"you\"        \"your\"      \n [11] \"yours\"      \"yourself\"   \"yourselves\" \"he\"         \"him\"       \n [16] \"his\"        \"himself\"    \"she\"        \"her\"        \"hers\"      \n [21] \"herself\"    \"it\"         \"its\"        \"itself\"     \"they\"      \n [26] \"them\"       \"their\"      \"theirs\"     \"themselves\" \"what\"      \n [31] \"which\"      \"who\"        \"whom\"       \"this\"       \"that\"      \n [36] \"these\"      \"those\"      \"am\"         \"is\"         \"are\"       \n [41] \"was\"        \"were\"       \"be\"         \"been\"       \"being\"     \n [46] \"have\"       \"has\"        \"had\"        \"having\"     \"do\"        \n [51] \"does\"       \"did\"        \"doing\"      \"would\"      \"should\"    \n [56] \"could\"      \"ought\"      \"i'm\"        \"you're\"     \"he's\"      \n [61] \"she's\"      \"it's\"       \"we're\"      \"they're\"    \"i've\"      \n [66] \"you've\"     \"we've\"      \"they've\"    \"i'd\"        \"you'd\"     \n [71] \"he'd\"       \"she'd\"      \"we'd\"       \"they'd\"     \"i'll\"      \n [76] \"you'll\"     \"he'll\"      \"she'll\"     \"we'll\"      \"they'll\"   \n [81] \"isn't\"      \"aren't\"     \"wasn't\"     \"weren't\"    \"hasn't\"    \n [86] \"haven't\"    \"hadn't\"     \"doesn't\"    \"don't\"      \"didn't\"    \n [91] \"won't\"      \"wouldn't\"   \"shan't\"     \"shouldn't\"  \"can't\"     \n [96] \"cannot\"     \"couldn't\"   \"mustn't\"    \"let's\"      \"that's\"    \n[101] \"who's\"      \"what's\"     \"here's\"     \"there's\"    \"when's\"    \n[106] \"where's\"    \"why's\"      \"how's\"      \"a\"          \"an\"        \n[111] \"the\"        \"and\"        \"but\"        \"if\"         \"or\"        \n[116] \"because\"    \"as\"         \"until\"      \"while\"      \"of\"        \n[121] \"at\"         \"by\"         \"for\"        \"with\"       \"about\"     \n[126] \"against\"    \"between\"    \"into\"       \"through\"    \"during\"    \n[131] \"before\"     \"after\"      \"above\"      \"below\"      \"to\"        \n[136] \"from\"       \"up\"         \"down\"       \"in\"         \"out\"       \n[141] \"on\"         \"off\"        \"over\"       \"under\"      \"again\"     \n[146] \"further\"    \"then\"       \"once\"       \"here\"       \"there\"     \n[151] \"when\"       \"where\"      \"why\"        \"how\"        \"all\"       \n[156] \"any\"        \"both\"       \"each\"       \"few\"        \"more\"      \n[161] \"most\"       \"other\"      \"some\"       \"such\"       \"no\"        \n[166] \"nor\"        \"not\"        \"only\"       \"own\"        \"same\"      \n[171] \"so\"         \"than\"       \"too\"        \"very\"       \"will\"      \n\ndaten_tokens &lt;- tokens_remove(daten_tokens, stopwords(\"english\"))\n\nJe nach Forschungsfrage k√∂nnen Stoppwortlisten angepasst werden, indem W√∂rter entfernt oder hinzugef√ºgt werden. Es ist aber auch m√∂glich eine eigene Liste zu erstellen.\n\n#W√∂rter aus der quanteda Stoppwortliste entfernen\nstoppw√∂rter &lt;- stopwords(\"english\")\nstoppw√∂rter &lt;- stoppw√∂rter[!stoppw√∂rter %in% c(\"i\", \"me\")]\n\n#W√∂rter der quanteda Stoppwortliste hinzuf√ºgen\nstoppw√∂rter &lt;- c(stoppw√∂rter, \"i\", \"me\")\n\n#Eigene Liste erstellen\neigene_stoppw√∂rter &lt;- c(\"hier\", \"eigene\", \"stoppw√∂rter\")"
  },
  {
    "objectID": "tutorial/02-einlesen-bereinigen.html#lemmatizing",
    "href": "tutorial/02-einlesen-bereinigen.html#lemmatizing",
    "title": "Sitzung 2 - Einlesen & Bereinigen von Text",
    "section": "2.6 Lemmatizing",
    "text": "2.6 Lemmatizing\nMit der Funktion tokens_wordstem()aus quanteda reduzieren wir alle tokens auf ihren Wortstamm.\n\ndaten_tokens &lt;- daten_tokens %&gt;% \n  tokens_wordstem() \n\ndaten_tokens %&gt;% \n  head(n=3)\n\nTokens consisting of 3 documents.\ntext1 :\n [1] \"nine\"      \"nobl\"      \"famili\"    \"fight\"     \"control\"   \"land\"     \n [7] \"westero\"   \"ancient\"   \"enemi\"     \"return\"    \"dormant\"   \"millennia\"\n\ntext2 :\n [1] \"chemistri\"      \"teacher\"        \"diagnos\"        \"inoper\"        \n [5] \"lung\"           \"cancer\"         \"turn\"           \"manufactur\"    \n [9] \"sell\"           \"methamphetamin\" \"former\"         \"student\"       \n[ ... and 4 more ]\n\ntext3 :\n [1] \"young\"      \"boy\"        \"vanish\"     \"small\"      \"town\"      \n [6] \"uncov\"      \"mysteri\"    \"involv\"     \"secret\"     \"experi\"    \n[11] \"terrifi\"    \"supernatur\"\n[ ... and 5 more ]"
  },
  {
    "objectID": "tutorial/02-einlesen-bereinigen.html#document-feature-matrix",
    "href": "tutorial/02-einlesen-bereinigen.html#document-feature-matrix",
    "title": "Sitzung 2 - Einlesen & Bereinigen von Text",
    "section": "2.7 Document-Feature-Matrix",
    "text": "2.7 Document-Feature-Matrix\nUm aus unseren tokens eine dfm zu machen nutzen wir die dfm()Funktion aus dem quanteda package.\n\ndaten_dfm &lt;- daten_tokens %&gt;% \n  dfm()"
  },
  {
    "objectID": "index.html#zeitplan",
    "href": "index.html#zeitplan",
    "title": "Automatisierte Inhaltsanalyse",
    "section": "Zeitplan",
    "text": "Zeitplan\nüìÖ Mi, 24. Juli\n\n09:00 - 12:00: 1Ô∏è‚É£ Einf√ºhrung & Preprocessing\n12:00 - 13:00: ü•ó Mittagspause\n13:00 - 15:00: 2Ô∏è‚É£ Co-Occurence-Analysen\n15:00 - 17:00: 3Ô∏è‚É£ Diktion√§re\n\nüìÖ Do, 25. Juli\n\n09:00 - 12:00: 4Ô∏è‚É£ Topic Modeling\n12:00 - 13:00: ü•ó Mittagspause\n13:00 - 15:00: 5Ô∏è‚É£ Qualit√§tskriterien\n15:00 - 16:00: 6Ô∏è‚É£ Ausblick"
  },
  {
    "objectID": "tutorial/02-einlesen-bereinigen.html#off-the-shelf-diktion√§re",
    "href": "tutorial/02-einlesen-bereinigen.html#off-the-shelf-diktion√§re",
    "title": "Sitzung 2 - Einlesen & Bereinigen von Text",
    "section": "7.1 Off-the-shelf Diktion√§re",
    "text": "7.1 Off-the-shelf Diktion√§re\nEs gibt viele off-the-shelf Diktion√§re. Der Einfachkeit halber nutzen wir hier zur Demonstation den data_dictionary_LSD2015aus dem quanteda Packet (Young & Soroka, 2012). #Soll hier noch ein Disclaimer wegen Validit√§t und Auswahl Diktion√§r etc. hin?\n\ndiktion√§r &lt;- data_dictionary_LSD2015\n\ndiktion√§r %&gt;% \n  head()\n\nDictionary object with 4 key entries.\n- [negative]:\n  - a lie, abandon*, abas*, abattoir*, abdicat*, aberra*, abhor*, abject*, abnormal*, abolish*, abominab*, abominat*, abrasiv*, absent*, abstrus*, absurd*, abus*, accident*, accost*, accursed* [ ... and 2,838 more ]\n- [positive]:\n  - ability*, abound*, absolv*, absorbent*, absorption*, abundanc*, abundant*, acced*, accentuat*, accept*, accessib*, acclaim*, acclamation*, accolad*, accommodat*, accomplish*, accord, accordan*, accorded*, accords [ ... and 1,689 more ]\n- [neg_positive]:\n  - best not, better not, no damag*, no no, not ability*, not able, not abound*, not absolv*, not absorbent*, not absorption*, not abundanc*, not abundant*, not acced*, not accentuat*, not accept*, not accessib*, not acclaim*, not acclamation*, not accolad*, not accommodat* [ ... and 1,701 more ]\n- [neg_negative]:\n  - not a lie, not abandon*, not abas*, not abattoir*, not abdicat*, not aberra*, not abhor*, not abject*, not abnormal*, not abolish*, not abominab*, not abominat*, not abrasiv*, not absent*, not abstrus*, not absurd*, not abus*, not accident*, not accost*, not accursed* [ ... and 2,840 more ]\n\n?data_dictionary_LSD2015\n\nNun wollen wir den dictionary auf unsere Daten anwenden. Diese m√ºssen daf√ºr im dfm-Format sein. Mit der Funktion dfm_lookup() aus dem quanteda Packet wird f√ºr jeden Text, also in diesem Fall f√ºr jede TV Show, geschaut, wie viele W√∂rter aus den ersten zwei Spalten des Diktion√§rs vorkommen. Die Funktion dfm_weight(scheme = \"prop\")setzt die Anzahl der dictionary W√∂rter ins Verh√§ltnis mit der L√§nge des Textes.\n\nsentiment_tvshows &lt;-  daten_dfm %&gt;% \n  dfm_weight(scheme = \"prop\") %&gt;% \n  dfm_lookup(dictionary = data_dictionary_LSD2015[1:2])\n\nsentiment_tvshows %&gt;% \n  head()\n\nDocument-feature matrix of: 6 documents, 2 features (50.00% sparse) and 0 docvars.\n       features\ndocs      negative   positive\n  text1 0.28571429 0         \n  text2 0          0         \n  text3 0.06666667 0         \n  text4 0          0.09090909\n  text5 0          0.22222222\n  text6 0.16666667 0.16666667"
  },
  {
    "objectID": "tutorial/02-einlesen-bereinigen.html#eigene-diktion√§re",
    "href": "tutorial/02-einlesen-bereinigen.html#eigene-diktion√§re",
    "title": "Sitzung 2 - Einlesen & Bereinigen von Text",
    "section": "7.2 Eigene Diktion√§re",
    "text": "7.2 Eigene Diktion√§re"
  },
  {
    "objectID": "tutorial/02-einlesen-bereinigen.html#anpassung-auf-kleinschreibung",
    "href": "tutorial/02-einlesen-bereinigen.html#anpassung-auf-kleinschreibung",
    "title": "Sitzung 2 - Einlesen & Bereinigen von Text",
    "section": "2.3 Anpassung auf Kleinschreibung",
    "text": "2.3 Anpassung auf Kleinschreibung\nMit der Funktion tokens_tolower()aus dem quanteda Packet k√∂nnen alle Buchstaben in Kleinbuchstaben umgeformt werden.\n\ndaten_tokens &lt;- tokens_tolower(daten_tokens)\n\ndaten_tokens %&gt;% \n  head(n=3)\n\nTokens consisting of 3 documents.\ntext1 :\n [1] \"nine\"     \"noble\"    \"families\" \"fight\"    \"for\"      \"control\" \n [7] \"over\"     \"the\"      \"lands\"    \"of\"       \"westeros\" \"while\"   \n[ ... and 9 more ]\n\ntext2 :\n [1] \"a\"             \"chemistry\"     \"teacher\"       \"diagnosed\"    \n [5] \"with\"          \"inoperable\"    \"lung\"          \"cancer\"       \n [9] \"turns\"         \"to\"            \"manufacturing\" \"and\"          \n[ ... and 13 more ]\n\ntext3 :\n [1] \"when\"      \"a\"         \"young\"     \"boy\"       \"vanishes\"  \"a\"        \n [7] \"small\"     \"town\"      \"uncovers\"  \"a\"         \"mystery\"   \"involving\"\n[ ... and 10 more ]"
  },
  {
    "objectID": "tutorial/02-einlesen-bereinigen.html#stemming",
    "href": "tutorial/02-einlesen-bereinigen.html#stemming",
    "title": "Sitzung 2 - Einlesen & Bereinigen von Text",
    "section": "2.6 Stemming",
    "text": "2.6 Stemming\nMit der Funktion tokens_wordstem()aus quanteda reduzieren wir alle tokens auf ihren Wortstamm.\n\ndaten_tokens &lt;- daten_tokens %&gt;% \n  tokens_wordstem() \n\ndaten_tokens %&gt;% \n  head(n=3)\n\nTokens consisting of 3 documents.\ntext1 :\n [1] \"nine\"      \"nobl\"      \"famili\"    \"fight\"     \"control\"   \"land\"     \n [7] \"westero\"   \"ancient\"   \"enemi\"     \"return\"    \"dormant\"   \"millennia\"\n\ntext2 :\n [1] \"chemistri\"      \"teacher\"        \"diagnos\"        \"inoper\"        \n [5] \"lung\"           \"cancer\"         \"turn\"           \"manufactur\"    \n [9] \"sell\"           \"methamphetamin\" \"former\"         \"student\"       \n[ ... and 4 more ]\n\ntext3 :\n [1] \"young\"      \"boy\"        \"vanish\"     \"small\"      \"town\"      \n [6] \"uncov\"      \"mysteri\"    \"involv\"     \"secret\"     \"experi\"    \n[11] \"terrifi\"    \"supernatur\"\n[ ... and 5 more ]"
  },
  {
    "objectID": "tutorial/02-einlesen-bereinigen.html#word-cloud-erster-blick-in-die-daten",
    "href": "tutorial/02-einlesen-bereinigen.html#word-cloud-erster-blick-in-die-daten",
    "title": "Sitzung 2 - Einlesen & Bereinigen von Text",
    "section": "2.9 Word cloud: Erster Blick in die Daten",
    "text": "2.9 Word cloud: Erster Blick in die Daten\nF√ºr einen ersten Einblick in die Daten lassen wir uns mit der topfeatures()Funktion aus dem quanteda Packet die 10 am h√§ufigsten vorkommenden features ausgeben.\n\ndaten_dfm %&gt;% \n  topfeatures(n = 10)\n\n  live   life famili    new  world  young follow friend   find   seri \n   108    108    107    103     75     74     74     70     69     65 \n\n\nDas Ergebnis k√∂nnen wir mit einer word cloud visualisieren. Hierf√ºr nutzen wir die textplot_wordcloud()Funktion aus dem quanteda.textplots Packet.\n\nword_cloud &lt;- daten_dfm %&gt;% \n  textplot_wordcloud(max_words = 100)\n\n\n\n\n√úbung: mit emoji einleiten ‚Äútest your knowledge‚Äù mit anderem Datensatz, der nicht zu gro√ü ist"
  },
  {
    "objectID": "tutorial/Tutorial_gesamt_alt.html",
    "href": "tutorial/Tutorial_gesamt_alt.html",
    "title": "Gesamter Code Stand 15.07",
    "section": "",
    "text": "Zun√§chst installieren und laden wir alle Packete, die wir heute und morgen brauchen.\n\n#install.packages(\"RCurl\")\n#install.packages(\"quanteda\")\n#install.packages(\"tidyverse)\n#install.packages(\"dplyr\")\n#install.packages(\"quanteda.textplots\")\n#install.packages(\"quanteda.textstats\")\n#install.packages(\"udpipe\")\n\nlibrary(\"RCurl\")\nlibrary(\"quanteda\")\nlibrary(\"tidyverse\")\nlibrary(\"dplyr\")\nlibrary(\"quanteda.textplots\")\nlibrary(\"quanteda.textstats\")\nlibrary(\"udpipe\")\n\nDann laden wir die Datei die hinter dem Link liegt mit der Funktion getURL() aus dem package Rcurl herunter. Mit einem Blick in das Environment sehen wir, dass die einzelnen W√∂rter mit einem ; getrennt werden . Daher brauchen wir die Funktion read.csv2() aus dem utils Packet - das Packet ist vorinstalliert und immer geladen - um die Daten in R einzulesen. Der Datensatz wird im Objekt daten_df gespeichert.\n\nurl &lt;-  getURL(\"https://raw.githubusercontent.com/valeriehase/Salamanca-CSS-SummerSchool/main/Processing%20text%20and%20text%20as%20data/data_tvseries.csv\")\ndaten_df &lt;-  read.csv2(text = url)\n\nAlternativ k√∂nnen Daten in einer .csv Datei auch mit einem , voneinander abgetrennt sein. Hier br√§uchte es dann die Funktion read.csv() zum Einlesen.\nNach dem Einlesen der Daten ist es √ºblich sich zun√§chst einen √úberblick √ºber die Daten zu verschaffen und zu kontrollieren, ob alles korrekt eingelesen wurde.\n\nhead(daten_df)\n\n                Title      Year Parental.Rating Rating Number.of.Votes\n1  1. Game of Thrones 2011‚Äì2019           TV-MA    9.2            2.3M\n2     2. Breaking Bad 2008‚Äì2013           TV-MA    9.5            2.1M\n3  3. Stranger Things 2016‚Äì2025           TV-14    8.7            1.3M\n4          4. Friends 1994‚Äì2004           TV-14    8.9            1.1M\n5 5. The Walking Dead 2010‚Äì2022           TV-MA    8.1            1.1M\n6         6. Sherlock 2010‚Äì2017           TV-14    9.1              1M\n                                                                                                                                                                                                                                    Description\n1                                                                                                           Nine noble families fight for control over the lands of Westeros, while an ancient enemy returns after being dormant for millennia.\n2                                                                    A chemistry teacher diagnosed with inoperable lung cancer turns to manufacturing and selling methamphetamine with a former student in order to secure his family's future.\n3                                                                                          When a young boy vanishes, a small town uncovers a mystery involving secret experiments, terrifying supernatural forces and one strange little girl.\n4                                                                                                        Follows the personal and professional lives of six twenty to thirty year-old friends living in the Manhattan borough of New York City.\n5                                                                                                              Sheriff Deputy Rick Grimes wakes up from a coma to learn the world is in ruins and must lead a group of survivors to stay alive.\n6 The quirky spin on Conan Doyle's iconic sleuth pitches him as a \"high-functioning sociopath\" in modern-day London. Assisting him in his investigations: Afghanistan War vet John Watson, who's introduced to Holmes by a mutual acquaintance.\n\nstr(daten_df)\n\n'data.frame':   900 obs. of  6 variables:\n $ Title          : chr  \"1. Game of Thrones\" \"2. Breaking Bad\" \"3. Stranger Things\" \"4. Friends\" ...\n $ Year           : chr  \"2011‚Äì2019\" \"2008‚Äì2013\" \"2016‚Äì2025\" \"1994‚Äì2004\" ...\n $ Parental.Rating: chr  \"TV-MA\" \"TV-MA\" \"TV-14\" \"TV-14\" ...\n $ Rating         : num  9.2 9.5 8.7 8.9 8.1 9.1 8.1 8.6 8.3 9 ...\n $ Number.of.Votes: chr  \"2.3M\" \"2.1M\" \"1.3M\" \"1.1M\" ...\n $ Description    : chr  \"Nine noble families fight for control over the lands of Westeros, while an ancient enemy returns after being do\"| __truncated__ \"A chemistry teacher diagnosed with inoperable lung cancer turns to manufacturing and selling methamphetamine wi\"| __truncated__ \"When a young boy vanishes, a small town uncovers a mystery involving secret experiments, terrifying supernatura\"| __truncated__ \"Follows the personal and professional lives of six twenty to thirty year-old friends living in the Manhattan bo\"| __truncated__ ...\n\nView(daten_df)"
  },
  {
    "objectID": "tutorial/Tutorial_gesamt_alt.html#encoding-issues-checken",
    "href": "tutorial/Tutorial_gesamt_alt.html#encoding-issues-checken",
    "title": "Gesamter Code Stand 15.07",
    "section": "2.1 Encoding issues checken",
    "text": "2.1 Encoding issues checken\nNach dem Einlesen haben wir bereits einen Blick in den Datensatz geworfen. Nun schauen wir uns gezielt die Textvariable description an, um zu √ºberpr√ºfen, ob alle Zeichen richtig dargestellt werden.\n\ndaten_df %&gt;% \n   select(Description) %&gt;% \n  head()\n\n                                                                                                                                                                                                                                    Description\n1                                                                                                           Nine noble families fight for control over the lands of Westeros, while an ancient enemy returns after being dormant for millennia.\n2                                                                    A chemistry teacher diagnosed with inoperable lung cancer turns to manufacturing and selling methamphetamine with a former student in order to secure his family's future.\n3                                                                                          When a young boy vanishes, a small town uncovers a mystery involving secret experiments, terrifying supernatural forces and one strange little girl.\n4                                                                                                        Follows the personal and professional lives of six twenty to thirty year-old friends living in the Manhattan borough of New York City.\n5                                                                                                              Sheriff Deputy Rick Grimes wakes up from a coma to learn the world is in ruins and must lead a group of survivors to stay alive.\n6 The quirky spin on Conan Doyle's iconic sleuth pitches him as a \"high-functioning sociopath\" in modern-day London. Assisting him in his investigations: Afghanistan War vet John Watson, who's introduced to Holmes by a mutual acquaintance.\n\n\nIn diesem Fall gibt es keine Encoding issues.\nWas tun falls doch?\n\n\nBeim Einlesen das richtige Encoding mitgeben\nManuell bereinigen\n\n\nBeim manuellen Bereinigen kann die Funktion gsub() helfen, die Zeichenketten ersetzen kann. Zum Beispiel so:\n\n#string mit encoding issues\nstring &lt;- \"Sch√É¬∂ne Gr√É¬º√É¬üe aus M√É¬ºnchen!\"\nprint(string)\n\n[1] \"Sch√É¬∂ne Gr√É¬º√É\\u009fe aus M√É¬ºnchen!\"\n\n#√úberpr√ºfen, ob \"M√ºnchen\" in string vorhanden ist\ncontains_m√ºnchen &lt;- grepl(\"M√ºnchen\", string)\nprint(contains_m√ºnchen)\n\n[1] FALSE\n\n#Zeichen manuell ersetzen\nstring_bereinigt &lt;- string %&gt;% \n  gsub(pattern = \"√É¬∂\", replacement =\"√∂\") %&gt;% \n  gsub(pattern = \"√É¬º\", replacement = \"√º\") %&gt;% \n  gsub(pattern = \"√É\\u009f\", replacement = \"√ü\") \nprint(string_bereinigt)\n\n[1] \"Sch√∂ne Gr√º√üe aus M√ºnchen!\"\n\n#√úberpr√ºfen, ob \"M√ºnchen\" in string_bereinigt vorhanden ist\ncontains_m√ºnchen &lt;- grepl(\"aus\", string_bereinigt)\nprint(contains_m√ºnchen)\n\n[1] TRUE"
  },
  {
    "objectID": "tutorial/Tutorial_gesamt_alt.html#tokenisierung-zahlen-urls-etc.-entfernen",
    "href": "tutorial/Tutorial_gesamt_alt.html#tokenisierung-zahlen-urls-etc.-entfernen",
    "title": "Gesamter Code Stand 15.07",
    "section": "2.2 Tokenisierung & Zahlen, URLs, etc. entfernen",
    "text": "2.2 Tokenisierung & Zahlen, URLs, etc. entfernen\nDie Funktion tokens()von quanteda erm√∂glicht es uns bei der Aufteilung von Text in tokens direkt bestimmte Zeichen zu entfernen. Hier entfernen wir Punkte, Zahlen, URLs und Symbole.\n\ndaten_tokens &lt;- tokens(daten_df$Description, what = \"word\", remove_punct = TRUE, remove_numbers = TRUE, remove_url = TRUE, remove_symbols = TRUE) #wollen wir das alles entfernen?\n\ndaten_tokens %&gt;% \n  head(n=3)\n\nTokens consisting of 3 documents.\ntext1 :\n [1] \"Nine\"     \"noble\"    \"families\" \"fight\"    \"for\"      \"control\" \n [7] \"over\"     \"the\"      \"lands\"    \"of\"       \"Westeros\" \"while\"   \n[ ... and 9 more ]\n\ntext2 :\n [1] \"A\"             \"chemistry\"     \"teacher\"       \"diagnosed\"    \n [5] \"with\"          \"inoperable\"    \"lung\"          \"cancer\"       \n [9] \"turns\"         \"to\"            \"manufacturing\" \"and\"          \n[ ... and 13 more ]\n\ntext3 :\n [1] \"When\"      \"a\"         \"young\"     \"boy\"       \"vanishes\"  \"a\"        \n [7] \"small\"     \"town\"      \"uncovers\"  \"a\"         \"mystery\"   \"involving\"\n[ ... and 10 more ]"
  },
  {
    "objectID": "tutorial/Tutorial_gesamt_alt.html#anpassung-auf-kleinschreibung",
    "href": "tutorial/Tutorial_gesamt_alt.html#anpassung-auf-kleinschreibung",
    "title": "Gesamter Code Stand 15.07",
    "section": "2.3 Anpassung auf Kleinschreibung",
    "text": "2.3 Anpassung auf Kleinschreibung\nMit der Funktion tokens_tolower()aus dem quanteda Packet k√∂nnen alle Buchstaben in Kleinbuchstaben umgeformt werden.\n\ndaten_tokens &lt;- tokens_tolower(daten_tokens)\n\ndaten_tokens %&gt;% \n  head(n=3)\n\nTokens consisting of 3 documents.\ntext1 :\n [1] \"nine\"     \"noble\"    \"families\" \"fight\"    \"for\"      \"control\" \n [7] \"over\"     \"the\"      \"lands\"    \"of\"       \"westeros\" \"while\"   \n[ ... and 9 more ]\n\ntext2 :\n [1] \"a\"             \"chemistry\"     \"teacher\"       \"diagnosed\"    \n [5] \"with\"          \"inoperable\"    \"lung\"          \"cancer\"       \n [9] \"turns\"         \"to\"            \"manufacturing\" \"and\"          \n[ ... and 13 more ]\n\ntext3 :\n [1] \"when\"      \"a\"         \"young\"     \"boy\"       \"vanishes\"  \"a\"        \n [7] \"small\"     \"town\"      \"uncovers\"  \"a\"         \"mystery\"   \"involving\"\n[ ... and 10 more ]"
  },
  {
    "objectID": "tutorial/Tutorial_gesamt_alt.html#stoppw√∂rter-entfernen",
    "href": "tutorial/Tutorial_gesamt_alt.html#stoppw√∂rter-entfernen",
    "title": "Gesamter Code Stand 15.07",
    "section": "2.4 Stoppw√∂rter entfernen",
    "text": "2.4 Stoppw√∂rter entfernen\nEs gibt verschiedene M√∂glichkeiten, Stoppw√∂rter zu entfernen. Am einfachsten ist dies mithilfe der in quanteda integrierten Stoppwortlisten m√∂glich. Diese sind in mehreren Sprachen verf√ºgbar, darunter auch Deutsch.\n\nstopwords(\"english\")\n\n  [1] \"i\"          \"me\"         \"my\"         \"myself\"     \"we\"        \n  [6] \"our\"        \"ours\"       \"ourselves\"  \"you\"        \"your\"      \n [11] \"yours\"      \"yourself\"   \"yourselves\" \"he\"         \"him\"       \n [16] \"his\"        \"himself\"    \"she\"        \"her\"        \"hers\"      \n [21] \"herself\"    \"it\"         \"its\"        \"itself\"     \"they\"      \n [26] \"them\"       \"their\"      \"theirs\"     \"themselves\" \"what\"      \n [31] \"which\"      \"who\"        \"whom\"       \"this\"       \"that\"      \n [36] \"these\"      \"those\"      \"am\"         \"is\"         \"are\"       \n [41] \"was\"        \"were\"       \"be\"         \"been\"       \"being\"     \n [46] \"have\"       \"has\"        \"had\"        \"having\"     \"do\"        \n [51] \"does\"       \"did\"        \"doing\"      \"would\"      \"should\"    \n [56] \"could\"      \"ought\"      \"i'm\"        \"you're\"     \"he's\"      \n [61] \"she's\"      \"it's\"       \"we're\"      \"they're\"    \"i've\"      \n [66] \"you've\"     \"we've\"      \"they've\"    \"i'd\"        \"you'd\"     \n [71] \"he'd\"       \"she'd\"      \"we'd\"       \"they'd\"     \"i'll\"      \n [76] \"you'll\"     \"he'll\"      \"she'll\"     \"we'll\"      \"they'll\"   \n [81] \"isn't\"      \"aren't\"     \"wasn't\"     \"weren't\"    \"hasn't\"    \n [86] \"haven't\"    \"hadn't\"     \"doesn't\"    \"don't\"      \"didn't\"    \n [91] \"won't\"      \"wouldn't\"   \"shan't\"     \"shouldn't\"  \"can't\"     \n [96] \"cannot\"     \"couldn't\"   \"mustn't\"    \"let's\"      \"that's\"    \n[101] \"who's\"      \"what's\"     \"here's\"     \"there's\"    \"when's\"    \n[106] \"where's\"    \"why's\"      \"how's\"      \"a\"          \"an\"        \n[111] \"the\"        \"and\"        \"but\"        \"if\"         \"or\"        \n[116] \"because\"    \"as\"         \"until\"      \"while\"      \"of\"        \n[121] \"at\"         \"by\"         \"for\"        \"with\"       \"about\"     \n[126] \"against\"    \"between\"    \"into\"       \"through\"    \"during\"    \n[131] \"before\"     \"after\"      \"above\"      \"below\"      \"to\"        \n[136] \"from\"       \"up\"         \"down\"       \"in\"         \"out\"       \n[141] \"on\"         \"off\"        \"over\"       \"under\"      \"again\"     \n[146] \"further\"    \"then\"       \"once\"       \"here\"       \"there\"     \n[151] \"when\"       \"where\"      \"why\"        \"how\"        \"all\"       \n[156] \"any\"        \"both\"       \"each\"       \"few\"        \"more\"      \n[161] \"most\"       \"other\"      \"some\"       \"such\"       \"no\"        \n[166] \"nor\"        \"not\"        \"only\"       \"own\"        \"same\"      \n[171] \"so\"         \"than\"       \"too\"        \"very\"       \"will\"      \n\ndaten_tokens &lt;- tokens_remove(daten_tokens, stopwords(\"english\"))\n\nJe nach Forschungsfrage k√∂nnen Stoppwortlisten angepasst werden, indem W√∂rter entfernt oder hinzugef√ºgt werden. Es ist aber auch m√∂glich eine eigene Liste zu erstellen.\n\n#W√∂rter aus der quanteda Stoppwortliste entfernen\nstoppw√∂rter &lt;- stopwords(\"english\")\nstoppw√∂rter &lt;- stoppw√∂rter[!stoppw√∂rter %in% c(\"i\", \"me\")]\n\n#W√∂rter der quanteda Stoppwortliste hinzuf√ºgen\nstoppw√∂rter &lt;- c(stoppw√∂rter, \"i\", \"me\")\n\n#Eigene Liste erstellen\neigene_stoppw√∂rter &lt;- c(\"hier\", \"eigene\", \"stoppw√∂rter\")"
  },
  {
    "objectID": "tutorial/Tutorial_gesamt_alt.html#vereinheitlichung",
    "href": "tutorial/Tutorial_gesamt_alt.html#vereinheitlichung",
    "title": "Gesamter Code Stand 15.07",
    "section": "2.5 Vereinheitlichung",
    "text": "2.5 Vereinheitlichung\nOft gibt es W√∂rter, die unterschiedliche Abk√ºrzungen oder Schreibweisen haben. Nehmen wir das Beispiel der Europ√§ischen Union, die auch mit EU oder E.U. abgek√ºrzt wird. Mit Hilfe der Funktion gsub() k√∂nnen wir strings mit anderen strings ersetzen.\n\nstring &lt;- \"Bei den EU Wahlen k√∂nnen alle B√ºrger*innen der Europ√§ischen Union w√§hlen gehen.\"\nstring &lt;- gsub(\"Europ√§ischen Union\", \"EU\", string)\nprint(string)\n\n[1] \"Bei den EU Wahlen k√∂nnen alle B√ºrger*innen der EU w√§hlen gehen.\""
  },
  {
    "objectID": "tutorial/Tutorial_gesamt_alt.html#stemming",
    "href": "tutorial/Tutorial_gesamt_alt.html#stemming",
    "title": "Gesamter Code Stand 15.07",
    "section": "2.6 Stemming",
    "text": "2.6 Stemming\nMit der Funktion tokens_wordstem()aus quanteda reduzieren wir alle tokens auf ihren Wortstamm.\n\ndaten_tokens &lt;- daten_tokens %&gt;% \n  tokens_wordstem() \n\ndaten_tokens %&gt;% \n  head(n=3)\n\nTokens consisting of 3 documents.\ntext1 :\n [1] \"nine\"      \"nobl\"      \"famili\"    \"fight\"     \"control\"   \"land\"     \n [7] \"westero\"   \"ancient\"   \"enemi\"     \"return\"    \"dormant\"   \"millennia\"\n\ntext2 :\n [1] \"chemistri\"      \"teacher\"        \"diagnos\"        \"inoper\"        \n [5] \"lung\"           \"cancer\"         \"turn\"           \"manufactur\"    \n [9] \"sell\"           \"methamphetamin\" \"former\"         \"student\"       \n[ ... and 4 more ]\n\ntext3 :\n [1] \"young\"      \"boy\"        \"vanish\"     \"small\"      \"town\"      \n [6] \"uncov\"      \"mysteri\"    \"involv\"     \"secret\"     \"experi\"    \n[11] \"terrifi\"    \"supernatur\"\n[ ... and 5 more ]"
  },
  {
    "objectID": "tutorial/Tutorial_gesamt_alt.html#document-feature-matrix",
    "href": "tutorial/Tutorial_gesamt_alt.html#document-feature-matrix",
    "title": "Gesamter Code Stand 15.07",
    "section": "2.7 Document-Feature-Matrix",
    "text": "2.7 Document-Feature-Matrix\nUm aus unseren tokens eine dfm zu machen nutzen wir die dfm()Funktion aus dem quanteda package.\n\ndaten_dfm &lt;- daten_tokens %&gt;% \n  dfm()"
  },
  {
    "objectID": "tutorial/Tutorial_gesamt_alt.html#selteneh√§ufige-features-entfernen",
    "href": "tutorial/Tutorial_gesamt_alt.html#selteneh√§ufige-features-entfernen",
    "title": "Gesamter Code Stand 15.07",
    "section": "2.8 Seltene/h√§ufige features entfernen",
    "text": "2.8 Seltene/h√§ufige features entfernen\nIm letzten Schritt des Preprocessings entfernen wir h√§ufig und selten vorkommende features aus der dfm. Das geht mit der Funktion dfm_trim()aus dem quanteda Packet.\nEs k√∂nnen unterschiedliche thresholds gesetzt werden - hier lassen wir nur features in der dfm die mindestens in 0.5% und h√∂chstens in 99% der Dokumente vorkommen. Das Argument docfreq_type = \"prop\"berechnet den Anteil der Dokumente, die ein bestimmtes feature beinhalten relativ zur Gesamtzahl der Dokumente. verbose = TRUEprinted w√§hrend der Ausf√ºhrung der Funktion Informationen √ºber den Rechenvorgang in die Konsole.\n\ndaten_dfm &lt;- daten_dfm %&gt;% \n  dfm_trim( min_docfreq = 0.005, \n            max_docfreq = 0.99, \n            docfreq_type = \"prop\", \n            verbose = TRUE)"
  },
  {
    "objectID": "tutorial/Tutorial_gesamt_alt.html#word-cloud-erster-blick-in-die-daten",
    "href": "tutorial/Tutorial_gesamt_alt.html#word-cloud-erster-blick-in-die-daten",
    "title": "Gesamter Code Stand 15.07",
    "section": "2.9 Word cloud: Erster Blick in die Daten",
    "text": "2.9 Word cloud: Erster Blick in die Daten\nF√ºr einen ersten Einblick in die Daten lassen wir uns mit der topfeatures()Funktion aus dem quanteda Packet die 10 am h√§ufigsten vorkommenden features ausgeben.\n\ndaten_dfm %&gt;% \n  topfeatures(n = 10)\n\n  live   life famili    new  world  young follow friend   find   seri \n   108    108    107    103     75     74     74     70     69     65 \n\n\nDas Ergebnis k√∂nnen wir mit einer word cloud visualisieren. Hierf√ºr nutzen wir die textplot_wordcloud()Funktion aus dem quanteda.textplots Packet.\n\nword_cloud &lt;- daten_dfm %&gt;% \n  textplot_wordcloud(max_words = 100)\n\n\n\n\n√úbung: mit emoji einleiten ‚Äútest your knowledge‚Äù mit anderem Datensatz, der nicht zu gro√ü ist"
  },
  {
    "objectID": "tutorial/Tutorial_gesamt_alt.html#off-the-shelf-diktion√§re",
    "href": "tutorial/Tutorial_gesamt_alt.html#off-the-shelf-diktion√§re",
    "title": "Gesamter Code Stand 15.07",
    "section": "7.1 Off-the-shelf Diktion√§re",
    "text": "7.1 Off-the-shelf Diktion√§re\nEs gibt viele off-the-shelf Diktion√§re. Der Einfachkeit halber nutzen wir hier zur Demonstation den data_dictionary_LSD2015aus dem quanteda Packet (Young & Soroka, 2012).\n‚Äì Soll hier noch ein Disclaimer wegen Validit√§t und Auswahl Diktion√§r etc. hin?\n\ndiktion√§r &lt;- data_dictionary_LSD2015\n\ndiktion√§r %&gt;% \n  head()\n\nDictionary object with 4 key entries.\n- [negative]:\n  - a lie, abandon*, abas*, abattoir*, abdicat*, aberra*, abhor*, abject*, abnormal*, abolish*, abominab*, abominat*, abrasiv*, absent*, abstrus*, absurd*, abus*, accident*, accost*, accursed* [ ... and 2,838 more ]\n- [positive]:\n  - ability*, abound*, absolv*, absorbent*, absorption*, abundanc*, abundant*, acced*, accentuat*, accept*, accessib*, acclaim*, acclamation*, accolad*, accommodat*, accomplish*, accord, accordan*, accorded*, accords [ ... and 1,689 more ]\n- [neg_positive]:\n  - best not, better not, no damag*, no no, not ability*, not able, not abound*, not absolv*, not absorbent*, not absorption*, not abundanc*, not abundant*, not acced*, not accentuat*, not accept*, not accessib*, not acclaim*, not acclamation*, not accolad*, not accommodat* [ ... and 1,701 more ]\n- [neg_negative]:\n  - not a lie, not abandon*, not abas*, not abattoir*, not abdicat*, not aberra*, not abhor*, not abject*, not abnormal*, not abolish*, not abominab*, not abominat*, not abrasiv*, not absent*, not abstrus*, not absurd*, not abus*, not accident*, not accost*, not accursed* [ ... and 2,840 more ]\n\n?data_dictionary_LSD2015\n\nNun wollen wir den Diktion√§r auf unsere Daten anwenden. Diese m√ºssen daf√ºr im dfm-Format sein. Mit der Funktion dfm_lookup() aus dem quanteda Packet wird f√ºr jeden Text, also in diesem Fall f√ºr jede TV Show, geschaut, wie viele W√∂rter aus den ersten zwei Spalten des Diktion√§rs vorkommen. Die Funktion dfm_weight(scheme = \"prop\")setzt die Anzahl der dictionary W√∂rter ins Verh√§ltnis mit der L√§nge des Textes.\n\nsentiment_tvshows &lt;-  daten_dfm %&gt;% \n  dfm_weight(scheme = \"prop\") %&gt;% \n  dfm_lookup(dictionary = data_dictionary_LSD2015[1:2])\n\nsentiment_tvshows %&gt;% \n  head()\n\nDocument-feature matrix of: 6 documents, 2 features (50.00% sparse) and 0 docvars.\n       features\ndocs      negative   positive\n  text1 0.28571429 0         \n  text2 0          0         \n  text3 0.06666667 0         \n  text4 0          0.09090909\n  text5 0          0.22222222\n  text6 0.16666667 0.16666667"
  },
  {
    "objectID": "tutorial/Tutorial_gesamt_alt.html#eigene-diktion√§re",
    "href": "tutorial/Tutorial_gesamt_alt.html#eigene-diktion√§re",
    "title": "Gesamter Code Stand 15.07",
    "section": "7.2 Eigene Diktion√§re",
    "text": "7.2 Eigene Diktion√§re"
  },
  {
    "objectID": "tutorial/02_cooccurence_kollokationen_postagging_ner.html",
    "href": "tutorial/02_cooccurence_kollokationen_postagging_ner.html",
    "title": "Sitzung 2: Co-Occurence Analyse, Kollokationen, POS-tagging und named entity recognition",
    "section": "",
    "text": "#Packages laden und Objekte erstellen\n\n#install.packages(\"RCurl\")\n#install.packages(\"quanteda\")\n#install.packages(\"tidyverse)\n#install.packages(\"dplyr\")\n#install.packages(\"quanteda.textplots\")\n#install.packages(\"quanteda.textstats\")\n#install.packages(\"udpipe\")\n\nlibrary(\"RCurl\")\nlibrary(\"quanteda\")\nlibrary(\"tidyverse\")\nlibrary(\"dplyr\")\nlibrary(\"quanteda.textplots\")\nlibrary(\"quanteda.textstats\")\nlibrary(\"udpipe\")\n\n\n#Daten laden\nurl &lt;-  getURL(\"https://raw.githubusercontent.com/valeriehase/Salamanca-CSS-SummerSchool/main/Processing%20text%20and%20text%20as%20data/data_tvseries.csv\")\ndaten_df &lt;-  read.csv2(text = url)\n\n#Tokens\nstopwords(\"english\")\n\n  [1] \"i\"          \"me\"         \"my\"         \"myself\"     \"we\"        \n  [6] \"our\"        \"ours\"       \"ourselves\"  \"you\"        \"your\"      \n [11] \"yours\"      \"yourself\"   \"yourselves\" \"he\"         \"him\"       \n [16] \"his\"        \"himself\"    \"she\"        \"her\"        \"hers\"      \n [21] \"herself\"    \"it\"         \"its\"        \"itself\"     \"they\"      \n [26] \"them\"       \"their\"      \"theirs\"     \"themselves\" \"what\"      \n [31] \"which\"      \"who\"        \"whom\"       \"this\"       \"that\"      \n [36] \"these\"      \"those\"      \"am\"         \"is\"         \"are\"       \n [41] \"was\"        \"were\"       \"be\"         \"been\"       \"being\"     \n [46] \"have\"       \"has\"        \"had\"        \"having\"     \"do\"        \n [51] \"does\"       \"did\"        \"doing\"      \"would\"      \"should\"    \n [56] \"could\"      \"ought\"      \"i'm\"        \"you're\"     \"he's\"      \n [61] \"she's\"      \"it's\"       \"we're\"      \"they're\"    \"i've\"      \n [66] \"you've\"     \"we've\"      \"they've\"    \"i'd\"        \"you'd\"     \n [71] \"he'd\"       \"she'd\"      \"we'd\"       \"they'd\"     \"i'll\"      \n [76] \"you'll\"     \"he'll\"      \"she'll\"     \"we'll\"      \"they'll\"   \n [81] \"isn't\"      \"aren't\"     \"wasn't\"     \"weren't\"    \"hasn't\"    \n [86] \"haven't\"    \"hadn't\"     \"doesn't\"    \"don't\"      \"didn't\"    \n [91] \"won't\"      \"wouldn't\"   \"shan't\"     \"shouldn't\"  \"can't\"     \n [96] \"cannot\"     \"couldn't\"   \"mustn't\"    \"let's\"      \"that's\"    \n[101] \"who's\"      \"what's\"     \"here's\"     \"there's\"    \"when's\"    \n[106] \"where's\"    \"why's\"      \"how's\"      \"a\"          \"an\"        \n[111] \"the\"        \"and\"        \"but\"        \"if\"         \"or\"        \n[116] \"because\"    \"as\"         \"until\"      \"while\"      \"of\"        \n[121] \"at\"         \"by\"         \"for\"        \"with\"       \"about\"     \n[126] \"against\"    \"between\"    \"into\"       \"through\"    \"during\"    \n[131] \"before\"     \"after\"      \"above\"      \"below\"      \"to\"        \n[136] \"from\"       \"up\"         \"down\"       \"in\"         \"out\"       \n[141] \"on\"         \"off\"        \"over\"       \"under\"      \"again\"     \n[146] \"further\"    \"then\"       \"once\"       \"here\"       \"there\"     \n[151] \"when\"       \"where\"      \"why\"        \"how\"        \"all\"       \n[156] \"any\"        \"both\"       \"each\"       \"few\"        \"more\"      \n[161] \"most\"       \"other\"      \"some\"       \"such\"       \"no\"        \n[166] \"nor\"        \"not\"        \"only\"       \"own\"        \"same\"      \n[171] \"so\"         \"than\"       \"too\"        \"very\"       \"will\"      \n\ndaten_tokens &lt;- daten_df$Description %&gt;% \n  tokens(what = \"word\",\n         remove_punct = TRUE, \n         remove_numbers = TRUE, \n         remove_url = TRUE, \n         remove_symbols = TRUE) %&gt;% \n  tokens_tolower() %&gt;% \n  tokens_remove(stopwords(\"english\")) %&gt;% \n  tokens_wordstem()\n\n#dfm\ndaten_dfm &lt;- daten_tokens %&gt;% \n  dfm() %&gt;% \n  dfm_trim( min_docfreq = 0.005, \n            max_docfreq = 0.99, \n            docfreq_type = \"prop\", \n            verbose = TRUE) \n\n\n3 Co-Occurrence-Analysen\nBevor wir zur Co-Occurence-Analyse kommen, gibt es auch eine Funktion, die es einem schnell und unkompliziert erm√∂glicht herauszufinden, in welchem Kontext ein Wort benutzt wird. Die hier gemeinte Funktion ist die kwic()Funktion aus dem quanteda Packet. Mit folgendem Code k√∂nnen wir beispielsweise herausfinden, in welchem Kontext das Wort hero vorkommt. In der Ausgabe werden jeweils die f√ºnf W√∂rter vor und nach dem Wort hero angezeigt.\n\ndaten_tokens %&gt;% \n  kwic(pattern = \"hero\", window = 5)\n\nKeyword-in-context with 12 matches.                                                          \n   [text75, 4]                famili former child | hero |\n  [text124, 3]                      stori saitama | hero |\n [text140, 18]      embark path destin turn rebel | hero |\n [text230, 24]        beast boy togeth becom team | hero |\n  [text241, 9]    hunter must recruit ragtag team | hero |\n [text292, 15]        know super power compound v | hero |\n  [text336, 5] superhero-admir boy enrol prestigi | hero |\n [text336, 10]     hero academi learn realli mean | hero |\n [text391, 10]      take challeng whole new level | hero |\n  [text498, 3]                       seven formid | hero |\n [text646, 11]   unit state america team everyday | hero |\n  [text756, 4]           hercul half-man half-god | hero |\n                                       \n now grown apart must reunit           \n just fun can defeat enemi             \n                                       \n                                       \n villain help prevent apocalyps impact \n put physic moral boundari test        \n academi learn realli mean hero        \n strongest superhero grant power       \n fallen apart desol dhananjay rajpoot  \n form arguabl power team ever          \n must transport known survivor plagu   \n fantast strength malevol stepmoth hera\n\n\nNun zur Co-Occurence-Analyse. Hierf√ºr m√ºssen wir zun√§chst die dfm in eine Feature Co-occurrence Matrix (fcm) umwandeln. Das machen wir mit der Funktion fcm() aus dem quanteda Packet.\n\ndaten_fcm &lt;- daten_dfm %&gt;% \n  fcm()\n\ndaten_fcm %&gt;% \n  head()\n\nFeature co-occurrence matrix of: 6 by 605 features.\n         features\nfeatures  famili fight control land ancient enemi return turn former student\n  famili       8     6       2    3       1     4      6    3      4       2\n  fight        0     1       2    2       2     2      2    1      0       2\n  control      0     0       0    1       1     1      1    0      0       0\n  land         0     0       0    0       1     1      1    0      0       1\n  ancient      0     0       0    0       0     2      1    0      0       0\n  enemi        0     0       0    0       0     0      2    0      0       0\n[ reached max_nfeat ... 595 more features ]\n\n\nBeim n√§chsten Schritt w√§hlen wir die features aus, die uns in unserer Analyse interessieren. Das machen wir mit der Funktion fcm_select()aus dem quanteda Packet.\n\ndaten_fcm &lt;- daten_fcm %&gt;% \n  fcm_select(pattern = c(\"famili\", \"crime\", \"america\", \"school\"), #hier noch bessere Begriffe vielleicht √ºber topfeatures oder topic modeling\n             selection = \"keep\")\n\nDann visualisieren wir die fcm mit der textplot_network()Funktion aus demquanteda.textplots() Paket. Wenn features im selben Dokument vorkommen, werden sie mit einer Linie verbunden. Umso dicker die Linie, desto √∂fter kommen die features miteinander vor.\n\ntextplot_network(daten_fcm)\n\n\n\n\nDiese Visualisierung gibt uns nun aber noch keine genauen Angaben dazu, wie oft ein feature mit einem anderen vorkommt. Um das herauszufinden, m√ºssen wir die fcm mit der convert()Funktion aus dem quanteda Packet in einen data frame umwandeln.\n\ndaten_fcm_df &lt;- daten_fcm %&gt;% \n  convert(to = \"data.frame\")\n\ndaten_fcm_df %&gt;% \n  head()\n\n   doc_id famili america crime school\n1  famili      8       3     3      7\n2 america      0       0     2      0\n3   crime      0       0     2      0\n4  school      0       0     0      2\n\n\nMit Hilfe von select()k√∂nnen wir uns nun einzelne H√§ufigkeiten, wie oft ein feature mit einem anderen feature vorkommt, ausgeben lassen.\n\ndaten_fcm_df %&gt;%\n  filter(doc_id == \"crime\") %&gt;% #Zeile\n  select(america) #Spalte #Frage: Wie kann es sein, dass crime america 0 ist und america crime 2?\n\n  america\n1       0\n\n\n\n\n4 Kollokationen und N-gramme\nUm herauszufinden, welche tokens oft hintereinander vorkommen, k√∂nnen wir die Funktion textstat_collocationsaus dem quanteda.textstats Packet verwenden.\n\ndaten_tokens %&gt;%\n  textstat_collocations(min_count = 10) %&gt;%\n  arrange(-lambda) %&gt;%\n  head(10)\n\n        collocation count count_nested length    lambda         z\n8         los angel    22            0      2 11.993246  7.856635\n9          new york    39            0      2  9.635906  6.744996\n5     serial killer    10            0      2  8.666634 11.850129\n4 person profession    13            0      2  7.818063 12.192676\n7     antholog seri    10            0      2  7.633523  8.612874\n1       high school    22            0      2  7.042098 16.492644\n3       best friend    25            0      2  7.006749 15.089627\n2         york citi    19            0      2  5.811625 16.073334\n6       seri follow    10            0      2  4.324217 11.364619\n\n\nIn einem weiteren Schritt kann es manchmal sinnvoll sein, Kollokationen f√ºr die Analyse zu einem token zusammenzufassen (dieser Schritt w√§re dann Teil des Preprocessings). Das l√§sst sich mit der tokens_compound()Funktion aus dem quanteda.textstats Packet umsetzen. Die Funktion verbindet die gegebenen tokens mit einem Unterstrich zu einem token.\n\nngramme &lt;- c(\"los angel\",\"new york citi\", \"serial killer\", \"high school\", \"best friend\")\ndaten_tokens_ngramme &lt;- tokens_compound(daten_tokens, pattern = phrase(ngramme))\n\nWie das nun in den Daten aussieht k√∂nnen wir mit Hilfe der kwic()Funktion aus dem quanteda Packet herausfinden (kwic steht f√ºr keywords in context).\n\ndaten_tokens_ngramme %&gt;% \n  kwic(pattern = c(\"los angel\",\"new york citi\", \"serial killer\", \"high school\", \"best friend\")) %&gt;% \n  head(n=30)\n\nKeyword-in-context with 0 matches.\n\n\n\n\n5 Part-of-speech tagging\nF√ºr das part of speech tagging nutzen wir das Packet UDPipe. Bevor wir unseren data frame in die udipie()Funktion geben, m√ºssen wir ihn ins tibble Format umformen und eine ID Variable erstellen. Des Weiteren bennen wir die Spalte value in text um. Das ist notwendig, weil as_tibble()die urspr√ºngliche Spalte Description in value umbenannt hat. Am Ende lassen wir uns nur einen Teil der Variablen ausgeben, damit das Ergebnis √ºbersichtlich bleibt.\n\ndaten_df_udpipe &lt;- daten_df$Description %&gt;%\n\n#Format f√ºr das udpipe Packet anpassen\n  as_tibble() %&gt;%\n  mutate(doc_id = paste0(\"text\", 1:n())) %&gt;% \n  rename(text = value) %&gt;%\n\n#Der Einfachheit halber nur f√ºr einen Text\n  slice(1) %&gt;%\n\n#part-of-speech tagging\n  udpipe(\"english\") \n\nWenn wir jetzt beispielsweise herausfinden wollen, mit welchen Adjektiven das Wort ‚Äúfamily‚Äù beschrieben wird, sieht der Code daf√ºr wie folgt aus:\n\n#Dataframe nach Nomen mit dem lemma \"family\" filtern\nadjectives_describing_family &lt;- daten_df_udpipe %&gt;%\n  filter(upos == \"NOUN\" & lemma == \"family\") %&gt;%\n\n#Den gefilterten Dataframe mit dem ungefilterten Dataframe joinen\n  inner_join(daten_df_udpipe, by = c(\"doc_id\", \"sentence_id\")) %&gt;%\n  \n#Gro√üen Dataframe nach Adjektiven filtern, die bei ihrer head_token Variable die family token_id haben\n  filter(upos.y == \"ADJ\" & head_token_id.y == token_id.x) %&gt;%\n\n#relevanten Variablen ausw√§hlen\n  select(doc_id, sentence_id, token_id = token_id.y, token = token.y, upos = upos.y)\n\nprint(adjectives_describing_family)\n\n  doc_id sentence_id token_id token upos\n1  text1           1        2 noble  ADJ\n\n\n\n\n6 Named entitiy recognition"
  },
  {
    "objectID": "tutorial/05_qualit√§tskriterien.html",
    "href": "tutorial/05_qualit√§tskriterien.html",
    "title": "Sitzung 5: Qualit√§tskriterien",
    "section": "",
    "text": "#Packages laden und Objekte erstellen\n\n#install.packages(\"RCurl\")\n#install.packages(\"quanteda\")\n#install.packages(\"tidyverse)\n#install.packages(\"dplyr\")\n#install.packages(\"quanteda.textplots\")\n#install.packages(\"quanteda.textstats\")\n#install.packages(\"udpipe\")\n\nlibrary(\"RCurl\")\nlibrary(\"quanteda\")\nlibrary(\"tidyverse\")\nlibrary(\"dplyr\")\nlibrary(\"quanteda.textplots\")\nlibrary(\"quanteda.textstats\")\nlibrary(\"udpipe\")\n\n\n#Daten laden\nurl &lt;-  getURL(\"https://raw.githubusercontent.com/valeriehase/Salamanca-CSS-SummerSchool/main/Processing%20text%20and%20text%20as%20data/data_tvseries.csv\")\ndaten_df &lt;-  read.csv2(text = url)\n\n#Tokens\nstopwords(\"english\")\n\n  [1] \"i\"          \"me\"         \"my\"         \"myself\"     \"we\"        \n  [6] \"our\"        \"ours\"       \"ourselves\"  \"you\"        \"your\"      \n [11] \"yours\"      \"yourself\"   \"yourselves\" \"he\"         \"him\"       \n [16] \"his\"        \"himself\"    \"she\"        \"her\"        \"hers\"      \n [21] \"herself\"    \"it\"         \"its\"        \"itself\"     \"they\"      \n [26] \"them\"       \"their\"      \"theirs\"     \"themselves\" \"what\"      \n [31] \"which\"      \"who\"        \"whom\"       \"this\"       \"that\"      \n [36] \"these\"      \"those\"      \"am\"         \"is\"         \"are\"       \n [41] \"was\"        \"were\"       \"be\"         \"been\"       \"being\"     \n [46] \"have\"       \"has\"        \"had\"        \"having\"     \"do\"        \n [51] \"does\"       \"did\"        \"doing\"      \"would\"      \"should\"    \n [56] \"could\"      \"ought\"      \"i'm\"        \"you're\"     \"he's\"      \n [61] \"she's\"      \"it's\"       \"we're\"      \"they're\"    \"i've\"      \n [66] \"you've\"     \"we've\"      \"they've\"    \"i'd\"        \"you'd\"     \n [71] \"he'd\"       \"she'd\"      \"we'd\"       \"they'd\"     \"i'll\"      \n [76] \"you'll\"     \"he'll\"      \"she'll\"     \"we'll\"      \"they'll\"   \n [81] \"isn't\"      \"aren't\"     \"wasn't\"     \"weren't\"    \"hasn't\"    \n [86] \"haven't\"    \"hadn't\"     \"doesn't\"    \"don't\"      \"didn't\"    \n [91] \"won't\"      \"wouldn't\"   \"shan't\"     \"shouldn't\"  \"can't\"     \n [96] \"cannot\"     \"couldn't\"   \"mustn't\"    \"let's\"      \"that's\"    \n[101] \"who's\"      \"what's\"     \"here's\"     \"there's\"    \"when's\"    \n[106] \"where's\"    \"why's\"      \"how's\"      \"a\"          \"an\"        \n[111] \"the\"        \"and\"        \"but\"        \"if\"         \"or\"        \n[116] \"because\"    \"as\"         \"until\"      \"while\"      \"of\"        \n[121] \"at\"         \"by\"         \"for\"        \"with\"       \"about\"     \n[126] \"against\"    \"between\"    \"into\"       \"through\"    \"during\"    \n[131] \"before\"     \"after\"      \"above\"      \"below\"      \"to\"        \n[136] \"from\"       \"up\"         \"down\"       \"in\"         \"out\"       \n[141] \"on\"         \"off\"        \"over\"       \"under\"      \"again\"     \n[146] \"further\"    \"then\"       \"once\"       \"here\"       \"there\"     \n[151] \"when\"       \"where\"      \"why\"        \"how\"        \"all\"       \n[156] \"any\"        \"both\"       \"each\"       \"few\"        \"more\"      \n[161] \"most\"       \"other\"      \"some\"       \"such\"       \"no\"        \n[166] \"nor\"        \"not\"        \"only\"       \"own\"        \"same\"      \n[171] \"so\"         \"than\"       \"too\"        \"very\"       \"will\"      \n\ndaten_tokens &lt;- daten_df$Description %&gt;% \n  tokens(what = \"word\",\n         remove_punct = TRUE, \n         remove_numbers = TRUE, \n         remove_url = TRUE, \n         remove_symbols = TRUE) %&gt;% \n  tokens_tolower() %&gt;% \n  tokens_remove(stopwords(\"english\")) %&gt;% \n  tokens_wordstem()\n\n#dfm\ndaten_dfm &lt;- daten_tokens %&gt;% \n  dfm() %&gt;% \n  dfm_trim( min_docfreq = 0.005, \n            max_docfreq = 0.99, \n            docfreq_type = \"prop\", \n            verbose = TRUE) \n\n\n9 Qualit√§tskriterien"
  },
  {
    "objectID": "tutorial/03_diktion√§re.html",
    "href": "tutorial/03_diktion√§re.html",
    "title": "Sitzung 3: Diktion√§re",
    "section": "",
    "text": "#Packages laden und Objekte erstellen\n#install.packages(\"RCurl\")\n#install.packages(\"quanteda\")\n#install.packages(\"tidyverse)\n#install.packages(\"dplyr\")\n#install.packages(\"quanteda.textplots\")\n#install.packages(\"quanteda.textstats\")\n#install.packages(\"udpipe\")\n\nlibrary(\"RCurl\")\nlibrary(\"quanteda\")\nlibrary(\"tidyverse\")\nlibrary(\"dplyr\")\nlibrary(\"quanteda.textplots\")\nlibrary(\"quanteda.textstats\")\nlibrary(\"udpipe\")\n#Daten laden\nurl &lt;-  getURL(\"https://raw.githubusercontent.com/valeriehase/Salamanca-CSS-SummerSchool/main/Processing%20text%20and%20text%20as%20data/data_tvseries.csv\")\ndaten_df &lt;-  read.csv2(text = url)\n\n#Tokens\nstopwords(\"english\")\n\n  [1] \"i\"          \"me\"         \"my\"         \"myself\"     \"we\"        \n  [6] \"our\"        \"ours\"       \"ourselves\"  \"you\"        \"your\"      \n [11] \"yours\"      \"yourself\"   \"yourselves\" \"he\"         \"him\"       \n [16] \"his\"        \"himself\"    \"she\"        \"her\"        \"hers\"      \n [21] \"herself\"    \"it\"         \"its\"        \"itself\"     \"they\"      \n [26] \"them\"       \"their\"      \"theirs\"     \"themselves\" \"what\"      \n [31] \"which\"      \"who\"        \"whom\"       \"this\"       \"that\"      \n [36] \"these\"      \"those\"      \"am\"         \"is\"         \"are\"       \n [41] \"was\"        \"were\"       \"be\"         \"been\"       \"being\"     \n [46] \"have\"       \"has\"        \"had\"        \"having\"     \"do\"        \n [51] \"does\"       \"did\"        \"doing\"      \"would\"      \"should\"    \n [56] \"could\"      \"ought\"      \"i'm\"        \"you're\"     \"he's\"      \n [61] \"she's\"      \"it's\"       \"we're\"      \"they're\"    \"i've\"      \n [66] \"you've\"     \"we've\"      \"they've\"    \"i'd\"        \"you'd\"     \n [71] \"he'd\"       \"she'd\"      \"we'd\"       \"they'd\"     \"i'll\"      \n [76] \"you'll\"     \"he'll\"      \"she'll\"     \"we'll\"      \"they'll\"   \n [81] \"isn't\"      \"aren't\"     \"wasn't\"     \"weren't\"    \"hasn't\"    \n [86] \"haven't\"    \"hadn't\"     \"doesn't\"    \"don't\"      \"didn't\"    \n [91] \"won't\"      \"wouldn't\"   \"shan't\"     \"shouldn't\"  \"can't\"     \n [96] \"cannot\"     \"couldn't\"   \"mustn't\"    \"let's\"      \"that's\"    \n[101] \"who's\"      \"what's\"     \"here's\"     \"there's\"    \"when's\"    \n[106] \"where's\"    \"why's\"      \"how's\"      \"a\"          \"an\"        \n[111] \"the\"        \"and\"        \"but\"        \"if\"         \"or\"        \n[116] \"because\"    \"as\"         \"until\"      \"while\"      \"of\"        \n[121] \"at\"         \"by\"         \"for\"        \"with\"       \"about\"     \n[126] \"against\"    \"between\"    \"into\"       \"through\"    \"during\"    \n[131] \"before\"     \"after\"      \"above\"      \"below\"      \"to\"        \n[136] \"from\"       \"up\"         \"down\"       \"in\"         \"out\"       \n[141] \"on\"         \"off\"        \"over\"       \"under\"      \"again\"     \n[146] \"further\"    \"then\"       \"once\"       \"here\"       \"there\"     \n[151] \"when\"       \"where\"      \"why\"        \"how\"        \"all\"       \n[156] \"any\"        \"both\"       \"each\"       \"few\"        \"more\"      \n[161] \"most\"       \"other\"      \"some\"       \"such\"       \"no\"        \n[166] \"nor\"        \"not\"        \"only\"       \"own\"        \"same\"      \n[171] \"so\"         \"than\"       \"too\"        \"very\"       \"will\"      \n\ndaten_tokens &lt;- daten_df$Description %&gt;% \n  tokens(what = \"word\",\n         remove_punct = TRUE, \n         remove_numbers = TRUE, \n         remove_url = TRUE, \n         remove_symbols = TRUE) %&gt;% \n  tokens_tolower() %&gt;% \n  tokens_remove(stopwords(\"english\")) %&gt;% \n  tokens_wordstem()\n\n#dfm\ndaten_dfm &lt;- daten_tokens %&gt;% \n  dfm() %&gt;% \n  dfm_trim( min_docfreq = 0.005, \n            max_docfreq = 0.99, \n            docfreq_type = \"prop\", \n            verbose = TRUE)"
  },
  {
    "objectID": "tutorial/03_diktion√§re.html#off-the-shelf-diktion√§re",
    "href": "tutorial/03_diktion√§re.html#off-the-shelf-diktion√§re",
    "title": "Sitzung 3: Diktion√§re",
    "section": "7.1 Off-the-shelf Diktion√§re",
    "text": "7.1 Off-the-shelf Diktion√§re\nEs gibt viele off-the-shelf Diktion√§re. Der Einfachkeit halber nutzen wir hier zur Demonstation den data_dictionary_LSD2015aus dem quanteda Packet (Young & Soroka, 2012).\n‚Äì Soll hier noch ein Disclaimer wegen Validit√§t und Auswahl Diktion√§r etc. hin?\n\ndiktion√§r &lt;- data_dictionary_LSD2015\n\ndiktion√§r %&gt;% \n  head()\n\nDictionary object with 4 key entries.\n- [negative]:\n  - a lie, abandon*, abas*, abattoir*, abdicat*, aberra*, abhor*, abject*, abnormal*, abolish*, abominab*, abominat*, abrasiv*, absent*, abstrus*, absurd*, abus*, accident*, accost*, accursed* [ ... and 2,838 more ]\n- [positive]:\n  - ability*, abound*, absolv*, absorbent*, absorption*, abundanc*, abundant*, acced*, accentuat*, accept*, accessib*, acclaim*, acclamation*, accolad*, accommodat*, accomplish*, accord, accordan*, accorded*, accords [ ... and 1,689 more ]\n- [neg_positive]:\n  - best not, better not, no damag*, no no, not ability*, not able, not abound*, not absolv*, not absorbent*, not absorption*, not abundanc*, not abundant*, not acced*, not accentuat*, not accept*, not accessib*, not acclaim*, not acclamation*, not accolad*, not accommodat* [ ... and 1,701 more ]\n- [neg_negative]:\n  - not a lie, not abandon*, not abas*, not abattoir*, not abdicat*, not aberra*, not abhor*, not abject*, not abnormal*, not abolish*, not abominab*, not abominat*, not abrasiv*, not absent*, not abstrus*, not absurd*, not abus*, not accident*, not accost*, not accursed* [ ... and 2,840 more ]\n\n?data_dictionary_LSD2015\n\nNun wollen wir den Diktion√§r auf unsere Daten anwenden. Diese m√ºssen daf√ºr im dfm-Format sein. Mit der Funktion dfm_lookup() aus dem quanteda Packet wird f√ºr jeden Text, also in diesem Fall f√ºr jede TV Show, geschaut, wie viele W√∂rter aus den ersten zwei Spalten des Diktion√§rs vorkommen. Die Funktion dfm_weight(scheme = \"prop\")setzt die Anzahl der dictionary W√∂rter ins Verh√§ltnis mit der L√§nge des Textes.\n\nsentiment_tvshows &lt;-  daten_dfm %&gt;% \n  dfm_weight(scheme = \"prop\") %&gt;% \n  dfm_lookup(dictionary = data_dictionary_LSD2015[1:2])\n\nsentiment_tvshows %&gt;% \n  head()\n\nDocument-feature matrix of: 6 documents, 2 features (50.00% sparse) and 0 docvars.\n       features\ndocs      negative   positive\n  text1 0.28571429 0         \n  text2 0          0         \n  text3 0.06666667 0         \n  text4 0          0.09090909\n  text5 0          0.22222222\n  text6 0.16666667 0.16666667"
  },
  {
    "objectID": "tutorial/03_diktion√§re.html#eigene-diktion√§re",
    "href": "tutorial/03_diktion√§re.html#eigene-diktion√§re",
    "title": "Sitzung 3: Diktion√§re",
    "section": "7.2 Eigene Diktion√§re",
    "text": "7.2 Eigene Diktion√§re"
  },
  {
    "objectID": "tutorial/04_topicmodeling.html",
    "href": "tutorial/04_topicmodeling.html",
    "title": "Sitzung 4: Topic Modeling",
    "section": "",
    "text": "#Packages laden und Objekte erstellen\n\n#install.packages(\"RCurl\")\n#install.packages(\"quanteda\")\n#install.packages(\"tidyverse)\n#install.packages(\"dplyr\")\n#install.packages(\"quanteda.textplots\")\n#install.packages(\"quanteda.textstats\")\n#install.packages(\"udpipe\")\n\nlibrary(\"RCurl\")\nlibrary(\"quanteda\")\nlibrary(\"tidyverse\")\nlibrary(\"dplyr\")\nlibrary(\"quanteda.textplots\")\nlibrary(\"quanteda.textstats\")\nlibrary(\"udpipe\")\n\n\n#Daten laden\nurl &lt;-  getURL(\"https://raw.githubusercontent.com/valeriehase/Salamanca-CSS-SummerSchool/main/Processing%20text%20and%20text%20as%20data/data_tvseries.csv\")\ndaten_df &lt;-  read.csv2(text = url)\n\n#Tokens\nstopwords(\"english\")\n\n  [1] \"i\"          \"me\"         \"my\"         \"myself\"     \"we\"        \n  [6] \"our\"        \"ours\"       \"ourselves\"  \"you\"        \"your\"      \n [11] \"yours\"      \"yourself\"   \"yourselves\" \"he\"         \"him\"       \n [16] \"his\"        \"himself\"    \"she\"        \"her\"        \"hers\"      \n [21] \"herself\"    \"it\"         \"its\"        \"itself\"     \"they\"      \n [26] \"them\"       \"their\"      \"theirs\"     \"themselves\" \"what\"      \n [31] \"which\"      \"who\"        \"whom\"       \"this\"       \"that\"      \n [36] \"these\"      \"those\"      \"am\"         \"is\"         \"are\"       \n [41] \"was\"        \"were\"       \"be\"         \"been\"       \"being\"     \n [46] \"have\"       \"has\"        \"had\"        \"having\"     \"do\"        \n [51] \"does\"       \"did\"        \"doing\"      \"would\"      \"should\"    \n [56] \"could\"      \"ought\"      \"i'm\"        \"you're\"     \"he's\"      \n [61] \"she's\"      \"it's\"       \"we're\"      \"they're\"    \"i've\"      \n [66] \"you've\"     \"we've\"      \"they've\"    \"i'd\"        \"you'd\"     \n [71] \"he'd\"       \"she'd\"      \"we'd\"       \"they'd\"     \"i'll\"      \n [76] \"you'll\"     \"he'll\"      \"she'll\"     \"we'll\"      \"they'll\"   \n [81] \"isn't\"      \"aren't\"     \"wasn't\"     \"weren't\"    \"hasn't\"    \n [86] \"haven't\"    \"hadn't\"     \"doesn't\"    \"don't\"      \"didn't\"    \n [91] \"won't\"      \"wouldn't\"   \"shan't\"     \"shouldn't\"  \"can't\"     \n [96] \"cannot\"     \"couldn't\"   \"mustn't\"    \"let's\"      \"that's\"    \n[101] \"who's\"      \"what's\"     \"here's\"     \"there's\"    \"when's\"    \n[106] \"where's\"    \"why's\"      \"how's\"      \"a\"          \"an\"        \n[111] \"the\"        \"and\"        \"but\"        \"if\"         \"or\"        \n[116] \"because\"    \"as\"         \"until\"      \"while\"      \"of\"        \n[121] \"at\"         \"by\"         \"for\"        \"with\"       \"about\"     \n[126] \"against\"    \"between\"    \"into\"       \"through\"    \"during\"    \n[131] \"before\"     \"after\"      \"above\"      \"below\"      \"to\"        \n[136] \"from\"       \"up\"         \"down\"       \"in\"         \"out\"       \n[141] \"on\"         \"off\"        \"over\"       \"under\"      \"again\"     \n[146] \"further\"    \"then\"       \"once\"       \"here\"       \"there\"     \n[151] \"when\"       \"where\"      \"why\"        \"how\"        \"all\"       \n[156] \"any\"        \"both\"       \"each\"       \"few\"        \"more\"      \n[161] \"most\"       \"other\"      \"some\"       \"such\"       \"no\"        \n[166] \"nor\"        \"not\"        \"only\"       \"own\"        \"same\"      \n[171] \"so\"         \"than\"       \"too\"        \"very\"       \"will\"      \n\ndaten_tokens &lt;- daten_df$Description %&gt;% \n  tokens(what = \"word\",\n         remove_punct = TRUE, \n         remove_numbers = TRUE, \n         remove_url = TRUE, \n         remove_symbols = TRUE) %&gt;% \n  tokens_tolower() %&gt;% \n  tokens_remove(stopwords(\"english\")) %&gt;% \n  tokens_wordstem()\n\n#dfm\ndaten_dfm &lt;- daten_tokens %&gt;% \n  dfm() %&gt;% \n  dfm_trim( min_docfreq = 0.005, \n            max_docfreq = 0.99, \n            docfreq_type = \"prop\", \n            verbose = TRUE) \n\n\n8 Topic Modeling"
  }
]